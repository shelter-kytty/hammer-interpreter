

err :         = print "[ Error ] could not parse for op"
pow : x y     = x^y
sqr : x       = x*2
mid : x y z   = x + {{y - x} * z}


tally = 0

pow_two : x = {
    if x 
    then x*2
    else 1
}

inc_by_result : f i = {
    i + f(i)
}

apply_tally := {
    _ := inc_by_result(pow_two ; tally)
}

collate : x = {
    if x > 0 then {
        apply_tally(), collate(x - 1)
    } else {
        unit
    }
}

exec : fns = {
    head = frst fns
    tail = scnd fns

    head()
    
    if tail != unit then {
        exec(tail)
    } else {
        print "cycle complete"
    }
}

exec(collate(100))




lower = 0

upper = 60

before = clock$

collate : x y = if x <= y then x^2, collate(x + 1 ; y) else unit

sum : chain = {
    head = frst chain
    tail = scnd chain
    
    if tail != unit 
    then head + sum(tail)
    else head
}

ttl = sum(print collate(lower ; upper))

after = clock()

printf(f"Measured {1} seconds before and {2} seconds \n\
after, totalling roughly {3} seconds to compute \n\
{4} with bounds {5} and {6}\n" ; before ; after ; after - before ; ttl ; lower ; upper
)


// Create closures
init : x y f = {
    printf(f"init:\nx = {1}\ny = {2}\nf = {3}\n" ; x ; y ; f)
    if x > y then {
        f(x), init(x - 1 ; y ; f)
    } else {
        unit
    }
}

// Fill list with captured results
fill : x y chain = {
    printf(f"fill:\nx = {1}\ny = {2}\nchain = {3}\n" ; x ; y ; chain)

    g = car chain
    tail = cdr chain

    if tail != unit then {
        g(y), fill(x ; y + 1 ; tail)
    } else {
        g(y), tail
    }
}

// Display results
enum : chain = {
    printf(f"enum:\nchain = {1}\n" ; chain)
    head = car chain
    tail = cdr chain

    print head

    if tail != unit then {
        enum(tail)
    } else {
        print "Complete"
    }
}


start = 0
end = 10

enum(fill(end) ; start ; init(end ; start ; {_ : x = _ : y = x+y}))


// Lady or girl test

// Encounters a stack overflow at values higher than 4 ;-;
// Returns the right values, though, idk how. The amount of stack
// frames needed for 10 is like 1150, so that's not happening lmfaoo
// idek how it USES that much, it's such a weird and contrived algorithm

a : k x1 x2 x3 x4 x5 = {
    a_ = a

    b := {
        g = k - 1
        <- a_$ g b x1 x2 x3 x4
    }

    if k <= 0 then x4() + x5() else <- b()
}

print a(3 ; {_ := 1} ; {_ := -1} ; {_ := -1} ; {_ := 1} ; {_ := 0})




l = 

foldr({_ : x y = x + y} ; 1 .. 100)
|> { _ : x = x/len(l) }
|> printf(f"The average is {1}\n" ; _)





quibble : words = {
    put "{"

    // Big stupid if statement
    worry : words = {
        type = typeOf(words)
        if type == 0 then {
            print "}"
        } else if type == 5 then {
            printf(f"{1}}\n" words)
        } else if type == 6 then {
            if typeOf(cdr words) == 5 then {
                printf(f"{1} and {2}}\n" ; car words ; cdr words)
            } else {
                printf(f"{1}, " ; car words)
                worry(cdr words)
            }
        } else unit
    }

    worry(words)
}

quibble({})
quibble({"ABC"})
quibble({"ABC" , "DEF"})
quibble({"ABC" , "DEF" , "G" , "H"})
quibble({"Me" , "myself" , "I"})
quibble({"Jack" , "Jill"})



// "Hashtable" implemented with cons cells
// It actually works though, which is hilarious
// '()' offsets final element, so that entries are always 
// in car and the table/end is always in cdr
table = {"A", 1} , {"B", 2} , {"C", 3} , {"D", 4}, unit

tableGet : table key = {
    entry = car table

    if { car entry } == key then cdr entry else {
        if cdr table then {
            tableGet(cdr table ; key)
        } else {
            unit
        }
    }
}

tableAdd : table key value = {
    cons cons key value table
}

tableDelete : table key = {
    if table then {
        entry = car table
    
        if {car entry} == key then {
            cdr table
        } else {
            entry , tableDelete(cdr table ; key)
        }
    } else unit
}

forEntries : table op = {
    if table then {
        op(car table)
        forEntries(cdr table ; op)
    } else unit
}

printEntry : entry = printf(f"{1} => {2}\n" ; car entry ; cdr entry )

value = tableGet(table "B")

tmpTable = tableAdd(table "F" 6)

newTable = tableAdd(tmpTable "E" 5)

print tableGet(newTable "E")

print tableGet(newTable "F")

tableSmaller = tableDelete(newTable "F")

put f"\nOG:\n"
forEntries(table printEntry)
put f"\nLorge:\n"
forEntries(newTable printEntry)
put f"\nSmol:\n"
forEntries(tableSmaller printEntry)





a : k x1 x2 x3 x4 x5 = {
    a_ = a

    b := {
        g = k - 1
        <- a_$ g b x1 x2 x3 x4
    }

    if k <= 0 then x4() + x5() else <- b()
}

print a(4 ; {_ := 1} ; {_ := -1} ; {_ := -1} ; {_ := 1} ; {_ := 0})









foldt : f l = {
    left = car l
    right = cdr l
    
    if typeOf(right) == 6 then {
        if typeOf(left) == 6
        then <- f(
            foldt(f left) 
            foldt(f right)
        )
        else <- f(
            left 
            foldt(f right)
        )
    } else {
        if typeOf(left) == 6
        then <- f(
            foldt(f left) 
            right
        )
        else <- f(
            left 
            right
        )
    }
}

trans : c = {
    left = car c
    right = cdr c

    if typeOf(right) == 6 then {
        if typeOf(left) == 6 
        then trans(right) , trans(left)
        else trans(right) , left
    } else {
        if typeOf(left) == 6
        then right , trans(left)
        else right , left
    }
}

minus : x y = x - y
ccons : x y = x , y
snocc : x y = y , x
list = 1 .. 5



r = foldr(minus ; list)

l = foldl(minus ; list)

print r
print l


rtmp = print foldr(ccons ; list)
ltmp = print foldl(ccons ; list)
wrrd = print foldr(snocc ; list)
drrw = print foldl(snocc ; list)

a = print foldt(minus ; rtmp)
b = print foldt(minus ; ltmp)
c = print foldt(minus ; wrrd)
d = print foldt(minus ; drrw)

x = print trans(rtmp)
y = print trans(ltmp)
z = print trans(wrrd)
w = print trans(drrw)

print foldt(minus ; x)
print foldt(minus ; y)
print foldt(minus ; z)
print foldt(minus ; w)


// Fn composition
// Creates a lambda at runtime that just calls the functions one
// after the other, nothing crazy
mul : x y = x*y
double : x = <- mul(x ; 2)

div : x y = x/y
half : x = <- div(x ; 2)

tmp : x = <- half(double(x))


test = print half . double

print test(2)


test_2 = print half . mul

print test_2(3 ; 6)


test_3 = print double . double . div

print test_3(10 ; 5)

first : x = {
    print "I'm first!"
    <- x * 2
}

second : x = {
    print "I'm second"
    <- x^2
}

both = second . first

print both(1)







// comparing 'and'/'or' operators
eval : x y op = {
    if op(x y) then print "A true statement!" else print "A false statement..."
}

_and : x y = {
    if x then (y?) else false
}

_or : x y = {
    if x then true else y?
}

eval$ (5 == 5) (typeOf(5) == 2) _and
eval$ (5 < 2) (5 > 4) _or

eval$ () true _and
eval$ () true _or

eval$ false (3 < 1) _and
eval$ (8 >= 9) (2 == 1) _or

opped_or : x y = {
    ((Int (x?)) + (Int (y?)))?
}

opped_and : x y = {
    ((Int (x?)) * (Int (y?)))?
}

print "Optimised:"
eval$ (5 == 5) (typeOf(5) == 2) opped_and
eval$ (5 < 2) (5 > 4) opped_or

eval$ () true opped_and
eval$ () true opped_or

eval$ false (3 < 1) opped_and
eval$ (8 >= 9) (2 == 1) opped_or


wrapped_and : x y = {
    x and y
}

wrapped_or : x y = {
    x or y
}

print "Optimised:"
eval$ (5 == 5) (typeOf(5) == 2) wrapped_and
eval$ (5 < 2) (5 > 4) wrapped_or

eval$ () true wrapped_and
eval$ () true wrapped_or

eval$ false (3 < 1) wrapped_and
eval$ (8 >= 9) (2 == 1) wrapped_or

print "Plain:"
if 5 == 5 and typeOf(5) == 2 then print "A true statement!" else print "A false statement..."
if 5 < 2 or 5 > 4 then print "A true statement!" else print "A false statement..."

if () and true then print "A true statement!" else print "A false statement..."
if () or true then print "A true statement!" else print "A false statement..."

if false and 3 < 1 then print "A true statement!" else print "A false statement..."
if 8 >= 9 or 2 == 1 then print "A true statement!" else print "A false statement..."



// Custom operators
// This one splits lists by the right operand

`<|> : a b = a[:b] , a[b+1:] 

list = 1 .. 10

lower , upper = list <|> 5

print lower
print upper